<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Pacifico&display=swap" rel="stylesheet">
    <title>FreshKeep</title>
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🥬</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            color: #262626;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .container {
            max-width: 935px;
            margin: 0 auto;
            padding: 0 16px;
        }

        .header {
            text-align: center;
            padding: 20px 0 16px;
            background: white;
            border-bottom: 1px solid #dbdbdb;
            margin-bottom: 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.06);
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 8px;
            font-family: 'Pacifico', cursive;
            font-weight: 400;
            letter-spacing: 0.5px;
            line-height: 1.1;
            color: #262626;
            text-shadow: none;
        }

        .header p {
            font-size: 14px;
            color: #8e8e8e;
            font-weight: 400;
            margin: 0;
            opacity: 1;
        }

        .add-form {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            border: 1px solid #dbdbdb;
        }

        .form-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr auto;
            gap: 15px;
            align-items: end;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #262626;
            font-size: 14px;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px 16px;
            border: 1.5px solid #dbdbdb;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
            background: #fafafa;
            font-family: 'Inter', inherit;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #0095f6;
            background: white;
        }

        .add-btn {
            padding: 12px 24px;
            background: #0095f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            height: fit-content;
            min-height: 44px;
            touch-action: manipulation;
            font-family: 'Inter', inherit;
        }

        .add-btn:hover {
            background: #1877f2;
            transform: translateY(-1px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 16px;
            margin: 20px 0;
            padding: 0 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            border: 1px solid #dbdbdb;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .stat-number {
            font-size: 24px;
            font-weight: 800;
            color: #262626;
            margin-bottom: 4px;
        }

        .stat-label {
            color: #8e8e8e;
            font-weight: 500;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            padding: 0 20px 40px;
        }

        .item-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            border: 1px solid #dbdbdb;
            transition: all 0.2s ease;
        }

        .item-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .item-header {
            padding: 16px 16px 12px;
        }

        .item-name {
            font-size: 16px;
            font-weight: 700;
            color: #262626;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .item-category {
            background: #f1f3f4;
            color: #5f6368;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            display: inline-block;
        }

        .item-details {
            padding: 0 16px;
            color: #8e8e8e;
            font-size: 14px;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .days-left {
            margin: 12px 16px;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
        }

        .fresh { 
            background: #e8f5e8; 
            color: #2e7d2e; 
            border: 1px solid #c3e6c3;
        }
        .warning { 
            background: #fff3cd; 
            color: #856404; 
            border: 1px solid #ffeaa7;
        }
        .expired { 
            background: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb;
        }

        .delete-btn {
            width: 100%;
            padding: 12px;
            background: #262626;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 14px;
            touch-action: manipulation;
            font-family: 'Inter', inherit;
        }

        .delete-btn:hover {
            background: #1a1a1a;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #0095f6;
            background: white;
            box-shadow: 0 0 0 3px rgba(0, 149, 246, 0.1);
        }

        .scan-btn:hover, .add-btn:hover {
            background: #1877f2;
            transform: translateY(-1px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 16px 0;
            padding: 0 16px;
            overflow-x: hidden;
        }

        .stat-card {
            background: white;
            padding: 16px 12px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #dbdbdb;
            transition: all 0.2s ease;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-card:active {
            transform: scale(0.98);
        }

        .stat-number {
            font-size: 28px;
            font-weight: 800;
            color: #262626;
            margin-bottom: 2px;
            line-height: 1;
        }

        .stat-label {
            color: #8e8e8e;
            font-weight: 500;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .items-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            padding: 0 16px 60px;
        }

        .item-card {
            background: white;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #dbdbdb;
            transition: all 0.2s ease;
        }

        .item-card:active {
            transform: scale(0.98);
        }

        .item-header {
            padding: 16px 16px 8px;
        }

        .item-name {
            font-size: 18px;
            font-weight: 700;
            color: #262626;
            margin-bottom: 8px;
            line-height: 1.2;
        }

        .delete-btn {
            width: 100%;
            padding: 16px;
            background: #262626;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 16px;
            touch-action: manipulation;
            font-family: 'Inter', inherit;
            min-height: 48px;
            -webkit-tap-highlight-color: transparent;
        }

        .delete-btn:active {
            background: #1a1a1a;
            transform: scale(0.98);
        }

        .storage-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            padding: 0 20px;
        }

        .tab-btn {
            padding: 10px 20px;
            background: white;
            border: 2px solid #dbdbdb;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', inherit;
        }

        .tab-btn.active {
            background: #0095f6;
            color: white;
            border-color: #0095f6;
        }

        .add-btn {
            padding: 16px 24px;
            background: #0095f6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            height: fit-content;
            min-height: 48px;
            touch-action: manipulation;
            font-family: 'Inter', inherit;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #0095f6;
        }

        .add-btn:hover {
            background: #1877f2;
            border-color: #1877f2;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .add-btn:active {
            transform: scale(0.98);
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 16px;
            border: 2px solid #dbdbdb;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
            background: #fafafa;
            font-family: 'Inter', inherit;
            min-height: 48px;
            box-sizing: border-box;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #0095f6;
            background: white;
            box-shadow: 0 0 0 3px rgba(0, 149, 246, 0.1);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 16px 0;
            padding: 0 16px;
            overflow-x: hidden;
        }

        .scan-btn:disabled {
            background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%) !important;
            cursor: not-allowed;
            transform: none;
            opacity: 0.7;
        }

        #scannerContainer {
            text-align: center;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 16px;
            margin: 8px 0;
        }

        .lookup-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 12px;
        }

        .lookup-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 12px;
        }

        .lookup-loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 12px;
        }

        .empty-state {
            text-align: center;
            color: #8e8e8e;
            font-size: 16px;
            padding: 40px 20px;
            background: white;
            border-radius: 16px;
            margin: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .storage-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 16px 0;
            padding: 0 16px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .storage-tabs::-webkit-scrollbar {
            display: none;
        }

        .tab-btn {
            padding: 12px 18px;
            background: white;
            border: 2px solid #dbdbdb;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', inherit;
            white-space: nowrap;
            min-width: fit-content;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .tab-btn:active {
            transform: scale(0.95);
        }

        .search-sort-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 16px;
            align-items: stretch;
        }

        .search-box {
            padding: 16px;
            border: 2px solid #dbdbdb;
            border-radius: 25px;
            font-size: 16px;
            font-family: 'Inter', inherit;
            background: white;
            transition: all 0.2s ease;
            min-height: 48px;
            box-sizing: border-box;
        }

        .sort-select {
            padding: 16px;
            border: 2px solid #dbdbdb;
            border-radius: 12px;
            font-size: 16px;
            font-family: 'Inter', inherit;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 48px;
            box-sizing: border-box;
        }

        .clear-search {
            padding: 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 48px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .clear-search:active {
            background: #5a6268;
            transform: scale(0.98);
        }

        .batch-remove {
            padding: 8px 12px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            min-height: 36px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .tab-btn:hover:not(.active) {
            background: #f8f9fa;
            border-color: #8e8e8e;
        }

        .tab-btn.pantry-tab.active {
            background: #28a745;
            border-color: #28a745;
            color: white;
        }

        .tab-btn.fridge-tab.active {
            background: #007bff;
            border-color: #007bff;
            color: white;
        }

        .tab-btn.freezer-tab.active {
            background: #17a2b8;
            border-color: #17a2b8;
            color: white;
        }

        .storage-location {
            margin: 8px 0 4px 0;
            font-size: 14px;
            font-weight: 500;
            padding: 6px 10px;
            border-radius: 16px;
            display: inline-block;
        }

        .location-pantry {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .location-fridge {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #99d6ff;
        }

        .location-freezer {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .item-details {
            padding: 0 16px;
            color: #8e8e8e;
            font-size: 14px;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .days-left {
            margin: 12px 16px;
            padding: 14px;
            border-radius: 12px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
        }

        .fresh { 
            background: #e8f5e8; 
            color: #2e7d2e; 
            border: 1px solid #c3e6c3;
        }
        .warning { 
            background: #fff3cd; 
            color: #856404; 
            border: 1px solid #ffeaa7;
        }
        .expired { 
            background: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb;
        }

        .batch-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #e1e5e9;
        }

        .batch-item-info {
            flex: 1;
        }

        .batch-item-name {
            font-weight: 600;
            color: #262626;
            font-size: 14px;
        }

        .batch-item-details {
            color: #8e8e8e;
            font-size: 12px;
            margin-top: 2px;
        }

        .batch-remove {
            padding: 4px 8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }

        @media (min-width: 769px) {
            .stats {
                grid-template-columns: repeat(5, 1fr);
                gap: 16px;
                margin: 20px 0;
                padding: 0 20px;
            }

            .items-grid {
                grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                gap: 16px;
                padding: 0 20px 40px;
            }

            .container {
                padding: 0 20px;
            }

            .search-sort-container {
                flex-direction: row;
                gap: 15px;
                margin: 20px;
                align-items: center;
            }

            .search-box {
                flex: 1;
                min-width: 200px;
            }

            .primary-scan:hover {
                background: #1877f2;
                border-color: #1877f2;
            }

            .secondary-scan:hover {
                background: #e8690b;
                border-color: #e8690b;
            }

            .tertiary-scan:hover {
                background: #5a3499;
                border-color: #5a3499;
            }

            .scan-tab:hover:not(:disabled) {
                transform: scale(1.02);
            }

            .tab-btn:hover:not(.active) {
                background: #f8f9fa;
                border-color: #8e8e8e;
            }

            .stat-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            }

            .item-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            }

            .clear-search:hover {
                background: #5a6268;
            }

            .scan-btn:hover, .add-btn:hover {
                transform: translateY(-1px);
            }

            .delete-btn:hover {
                background: #1a1a1a;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🥬 FreshKeep</h1>
            <p>Track everything in your pantry, fridge, and freezer - never waste food again!</p>
            <div id="connectionStatus" style="font-size: 12px; margin-top: 5px; padding: 4px 8px; border-radius: 4px; display: inline-block;">
                Connecting to database...
            </div>
        </div>

        <div class="add-form">
            <div class="scan-section" style="margin-bottom: 20px;">
                <div class="scan-buttons" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px;">
                    <button class="tab-btn scan-tab primary-scan" id="scanBtn" onclick="toggleScanner()">
                        📱 Scan Barcode
                    </button>
                    <button class="tab-btn scan-tab secondary-scan" id="batchBtn" onclick="toggleBatchMode()">
                        📦 Batch Scan
                    </button>
                    <button class="tab-btn scan-tab tertiary-scan" onclick="toggleManualEntry()">
                        ⌨️ Manual Entry
                    </button>
                </div>
                
                <div id="manualEntry" style="display: none; margin-bottom: 15px;">
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="manualBarcode" placeholder="Enter barcode number..." style="flex: 1; padding: 10px; border: 2px solid #e1e5e9; border-radius: 6px; font-size: 16px;">
                        <button onclick="lookupManualBarcode()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">Lookup</button>
                    </div>
                </div>

                <div id="batchQueue" style="display: none; margin-bottom: 15px;">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 2px dashed #dee2e6;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>Batch Mode - Items in Queue: <span id="batchCount">0</span></strong>
                            <div>
                                <button onclick="addAllBatchItems()" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 5px;">Add All</button>
                                <button onclick="clearBatchQueue()" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear Queue</button>
                            </div>
                        </div>
                        <div id="batchItems" style="max-height: 200px; overflow-y: auto;"></div>
                    </div>
                </div>

                <div id="scannerContainer" style="display: none; margin-top: 15px;">
                    <div style="position: relative; display: inline-block;">
                        <video id="video" autoplay muted playsinline style="width: 100%; max-width: 400px; border-radius: 8px; display: block;"></video>
                        <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #ff0000; width: 200px; height: 100px; border-radius: 8px; pointer-events: none; box-shadow: 0 0 0 9999px rgba(0,0,0,0.3);"></div>
                    </div>
                    <div style="margin-top: 10px; text-align: center;">
                        <button onclick="stopScanner()" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Stop Scanning</button>
                        <span id="scanMode" style="margin-left: 15px; font-weight: 500;"></span>
                    </div>
                </div>
                <div id="lookupStatus" style="margin-top: 10px; padding: 10px; border-radius: 6px; display: none;"></div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label for="itemName">Item Name</label>
                    <input type="text" id="itemName" placeholder="e.g., Ground beef, Rice, Milk... or scan barcode above" required>
                </div>
                <div class="form-group">
                    <label for="storageLocation">Storage Location</label>
                    <select id="storageLocation" onchange="toggleDateField()">
                        <option value="Pantry">🏠 Pantry</option>
                        <option value="Fridge">❄️ Fridge</option>
                        <option value="Freezer">🧊 Freezer</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="category">Category</label>
                    <select id="category">
                        <option value="Meat">Meat</option>
                        <option value="Vegetables">Vegetables</option>
                        <option value="Dairy">Dairy</option>
                        <option value="Grains">Grains</option>
                        <option value="Canned">Canned Goods</option>
                        <option value="Snacks">Snacks</option>
                        <option value="Condiments">Condiments</option>
                        <option value="Beverages">Beverages</option>
                        <option value="Desserts">Desserts</option>
                        <option value="Prepared">Prepared Foods</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div class="form-group" id="dateGroup">
                    <label for="storedDate" id="dateLabel">Date Added</label>
                    <input type="date" id="storedDate" required>
                </div>
                <button class="add-btn" onclick="addItem()">Add Item</button>
            </div>
        </div>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-number" id="totalItems">0</div>
                <div class="stat-label">Total Items</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="pantryItems">0</div>
                <div class="stat-label">Pantry</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="fridgeItems">0</div>
                <div class="stat-label">Fridge</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="freezerItems">0</div>
                <div class="stat-label">Freezer</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="expiringSoon">0</div>
                <div class="stat-label">Use Soon</div>
            </div>
        </div>

        <div class="storage-tabs">
            <button class="tab-btn active" onclick="switchTab('all')" id="allTab">All Items</button>
            <button class="tab-btn pantry-tab" onclick="switchTab('pantry')" id="pantryTab">🏠 Pantry</button>
            <button class="tab-btn fridge-tab" onclick="switchTab('fridge')" id="fridgeTab">❄️ Fridge</button>
            <button class="tab-btn freezer-tab" onclick="switchTab('freezer')" id="freezerTab">🧊 Freezer</button>
        </div>

        <div class="search-sort-container">
            <input type="text" class="search-box" id="searchBox" placeholder="🔍 Search items by name..." onkeyup="handleSearch()">
            <select class="sort-select" id="sortSelect" onchange="handleSort()">
                <option value="expiration">Sort by Expiration</option>
                <option value="name">Sort by Name</option>
                <option value="date-added">Sort by Date Added</option>
                <option value="location">Sort by Location</option>
                <option value="category">Sort by Category</option>
            </select>
            <button class="clear-search" onclick="clearSearch()">Clear</button>
        </div>

        <div class="items-grid" id="itemsGrid">
            <div class="empty-state">
                Your storage is empty! Add some items to get started.
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, onSnapshot, query, orderBy } from 'https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js';

        // Firebase configuration - Replace with your actual config
        // To get your config:
        // 1. Go to https://console.firebase.google.com
        // 2. Create a new project or select existing one
        // 3. Add a web app to your project
        // 4. Enable Firestore Database in your project
        // 5. Copy the config object from Firebase console
        const firebaseConfig = {
            apiKey: "AIzaSyDlhIJzu9Ln_R2fAAgakKfFzzJgTDzautE",
            authDomain: "freshkeep-34a12.firebaseapp.com",
            projectId: "freshkeep-34a12",
            storageBucket: "freshkeep-34a12.firebasestorage.app",
            messagingSenderId: "332100833248",
            appId: "1:332100833248:web:e920634dc1485dfdcda585",
            measurementId: "G-WBKNQGT7JJ"
        };

        // Initialize Firebase
        try {
            window.firebaseApp = initializeApp(firebaseConfig);
            window.db = getFirestore(window.firebaseApp);
            window.firestoreUtils = { collection, addDoc, getDocs, deleteDoc, doc, onSnapshot, query, orderBy };
            console.log('Firebase initialized successfully');
            updateConnectionStatus('firebase');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            // Fallback to local storage if Firebase fails
            window.db = null;
            updateConnectionStatus('local');
        }

        // Update connection status indicator
        function updateConnectionStatus(type) {
            const statusEl = document.getElementById('connectionStatus');
            if (!statusEl) return;

            if (type === 'firebase') {
                statusEl.textContent = '☁️ Connected to Firebase';
                statusEl.style.background = '#d4edda';
                statusEl.style.color = '#155724';
                statusEl.style.border = '1px solid #c3e6cb';
            } else {
                statusEl.textContent = '💾 Using Local Storage';
                statusEl.style.background = '#fff3cd';
                statusEl.style.color = '#856404';
                statusEl.style.border = '1px solid #ffeaa7';
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
    <script>
        let foodItems = [];
        let isScanning = false;
        let isBatchMode = false;
        let batchQueue = [];
        let currentTab = 'all';
        let searchTerm = '';
        let sortBy = 'expiration';

        // Firestore service functions
        const FirestoreService = {
            // Save a food item to Firestore
            async saveFoodItem(item) {
                if (!window.db) {
                    console.log('Firestore not available, using local storage');
                    return this.saveToLocalStorage(item);
                }

                try {
                    // Convert dates to Firestore timestamps
                    const firestoreItem = {
                        ...item,
                        storedDate: item.storedDate.toISOString(),
                        addedDate: item.addedDate.toISOString()
                    };

                    const docRef = await window.firestoreUtils.addDoc(
                        window.firestoreUtils.collection(window.db, 'foodItems'),
                        firestoreItem
                    );

                    // Update local item with Firestore ID
                    item.firestoreId = docRef.id;
                    console.log('Food item saved to Firestore:', docRef.id);
                    return docRef.id;
                } catch (error) {
                    console.error('Error saving to Firestore:', error);
                    // Fallback to local storage
                    return this.saveToLocalStorage(item);
                }
            },

            // Load all food items from Firestore
            async loadFoodItems() {
                if (!window.db) {
                    console.log('Firestore not available, using local storage');
                    return this.loadFromLocalStorage();
                }

                try {
                    const querySnapshot = await window.firestoreUtils.getDocs(
                        window.firestoreUtils.collection(window.db, 'foodItems')
                    );

                    const items = [];
                    querySnapshot.forEach((doc) => {
                        const data = doc.data();
                        const item = {
                            ...data,
                            firestoreId: doc.id,
                            storedDate: new Date(data.storedDate),
                            addedDate: new Date(data.addedDate)
                        };
                        items.push(item);
                    });

                    console.log('Loaded', items.length, 'items from Firestore');
                    return items;
                } catch (error) {
                    console.error('Error loading from Firestore:', error);
                    // Fallback to local storage
                    return this.loadFromLocalStorage();
                }
            },

            // Delete a food item from Firestore
            async deleteFoodItem(item) {
                if (!window.db || !item.firestoreId) {
                    console.log('Firestore not available or no Firestore ID, using local storage');
                    return this.deleteFromLocalStorage(item);
                }

                try {
                    await window.firestoreUtils.deleteDoc(
                        window.firestoreUtils.doc(window.db, 'foodItems', item.firestoreId)
                    );
                    console.log('Food item deleted from Firestore:', item.firestoreId);
                    return true;
                } catch (error) {
                    console.error('Error deleting from Firestore:', error);
                    return this.deleteFromLocalStorage(item);
                }
            },

            // Setup real-time listener for food items
            setupRealtimeListener() {
                if (!window.db) {
                    console.log('Firestore not available, skipping real-time listener');
                    return;
                }

                try {
                    const unsubscribe = window.firestoreUtils.onSnapshot(
                        window.firestoreUtils.collection(window.db, 'foodItems'),
                        (snapshot) => {
                            const items = [];
                            snapshot.forEach((doc) => {
                                const data = doc.data();
                                const item = {
                                    ...data,
                                    firestoreId: doc.id,
                                    storedDate: new Date(data.storedDate),
                                    addedDate: new Date(data.addedDate)
                                };
                                items.push(item);
                            });

                            foodItems = items;
                            updateDisplay();
                            console.log('Real-time update: loaded', items.length, 'items');
                        },
                        (error) => {
                            console.error('Real-time listener error:', error);
                        }
                    );

                    // Store unsubscribe function globally for cleanup
                    window.firestoreUnsubscribe = unsubscribe;
                } catch (error) {
                    console.error('Error setting up real-time listener:', error);
                }
            },

            // Local storage fallback methods
            saveToLocalStorage(item) {
                const stored = localStorage.getItem('freshkeep-items') || '[]';
                const items = JSON.parse(stored);

                // Convert dates to strings for storage
                const storageItem = {
                    ...item,
                    storedDate: item.storedDate.toISOString(),
                    addedDate: item.addedDate.toISOString()
                };

                items.push(storageItem);
                localStorage.setItem('freshkeep-items', JSON.stringify(items));
                console.log('Saved to local storage');
                return item.id;
            },

            loadFromLocalStorage() {
                const stored = localStorage.getItem('freshkeep-items') || '[]';
                const items = JSON.parse(stored);

                return items.map(item => ({
                    ...item,
                    storedDate: new Date(item.storedDate),
                    addedDate: new Date(item.addedDate)
                }));
            },

            deleteFromLocalStorage(item) {
                const stored = localStorage.getItem('freshkeep-items') || '[]';
                const items = JSON.parse(stored);
                const filtered = items.filter(storedItem => storedItem.id !== item.id);
                localStorage.setItem('freshkeep-items', JSON.stringify(filtered));
                console.log('Deleted from local storage');
                return true;
            }
        };

        // Storage guidelines (months) - varies by location
        const storageGuidelines = {
            'Pantry': {
                'Meat': 0, 'Vegetables': 12, 'Dairy': 0, 'Grains': 24, 'Canned': 36, 
                'Snacks': 12, 'Condiments': 24, 'Beverages': 12, 'Desserts': 12, 
                'Prepared': 6, 'Other': 12
            },
            'Fridge': {
                'Meat': 0.25, 'Vegetables': 2, 'Dairy': 1, 'Grains': 1, 'Canned': 0.5,
                'Snacks': 3, 'Condiments': 6, 'Beverages': 1, 'Desserts': 1, 
                'Prepared': 0.25, 'Other': 1
            },
            'Freezer': {
                'Meat': 6, 'Vegetables': 12, 'Dairy': 3, 'Grains': 6, 'Canned': 0,
                'Snacks': 6, 'Condiments': 12, 'Beverages': 6, 'Desserts': 4, 
                'Prepared': 3, 'Other': 6
            }
        };

        // Initialize app after DOM loads
        window.addEventListener('DOMContentLoaded', async function() {
            document.getElementById('storedDate').valueAsDate = new Date();

            // Load existing items from Firestore
            try {
                foodItems = await FirestoreService.loadFoodItems();
                updateDisplay();

                // Setup real-time listener for live updates
                FirestoreService.setupRealtimeListener();
            } catch (error) {
                console.error('Error loading food items:', error);
            }
        });

        function toggleScanner() {
            if (isScanning) {
                stopScanner();
            } else {
                isBatchMode = false;
                startScanner();
            }
        }

        function toggleBatchMode() {
            if (isScanning && isBatchMode) {
                stopScanner();
            } else {
                isBatchMode = true;
                document.getElementById('batchQueue').style.display = 'block';
                startScanner();
            }
        }

        function toggleManualEntry() {
            const manualEntry = document.getElementById('manualEntry');
            const isVisible = manualEntry.style.display !== 'none';
            manualEntry.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                document.getElementById('manualBarcode').focus();
            }
        }

        function toggleDateField() {
            const location = document.getElementById('storageLocation').value;
            const dateLabel = document.getElementById('dateLabel');
            
            if (location === 'Freezer') {
                dateLabel.textContent = 'Date Frozen';
            } else {
                dateLabel.textContent = 'Date Added';
            }
        }

        async function addItem() {
            const name = document.getElementById('itemName').value.trim();
            const category = document.getElementById('category').value;
            const location = document.getElementById('storageLocation').value;
            const storedDate = document.getElementById('storedDate').value;

            if (!name || !storedDate) {
                alert('Please fill in all fields!');
                return;
            }

            const dateParts = storedDate.split('-');
            const localDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);

            const item = {
                id: Date.now(),
                name: name,
                category: category,
                location: location,
                storedDate: localDate,
                addedDate: new Date()
            };

            try {
                // Save to Firestore
                await FirestoreService.saveFoodItem(item);

                // If not using real-time listener, add to local array
                if (!window.firestoreUnsubscribe) {
                    foodItems.push(item);
                    updateDisplay();
                }

                document.getElementById('itemName').value = '';
                document.getElementById('storedDate').valueAsDate = new Date();
            } catch (error) {
                console.error('Error adding item:', error);
                alert('Error adding item. Please try again.');
            }
        }

        async function deleteItem(id) {
            try {
                // Find the item to delete
                const itemToDelete = foodItems.find(item => item.id === id);
                if (!itemToDelete) {
                    console.error('Item not found:', id);
                    return;
                }

                // Delete from Firestore
                await FirestoreService.deleteFoodItem(itemToDelete);

                // If not using real-time listener, remove from local array
                if (!window.firestoreUnsubscribe) {
                    foodItems = foodItems.filter(item => item.id !== id);
                    updateDisplay();
                }
            } catch (error) {
                console.error('Error deleting item:', error);
                alert('Error deleting item. Please try again.');
            }
        }

        function switchTab(tab) {
            currentTab = tab;
            
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tab + 'Tab').classList.add('active');
            
            updateDisplay();
        }

        function handleSearch() {
            searchTerm = document.getElementById('searchBox').value.toLowerCase();
            updateDisplay();
        }

        function handleSort() {
            sortBy = document.getElementById('sortSelect').value;
            updateDisplay();
        }

        function clearSearch() {
            document.getElementById('searchBox').value = '';
            document.getElementById('sortSelect').value = 'expiration';
            searchTerm = '';
            sortBy = 'expiration';
            updateDisplay();
        }

        function filterAndSortItems(items) {
            let filteredItems = items;

            // Filter by search term
            if (searchTerm) {
                filteredItems = filteredItems.filter(item => 
                    item.name.toLowerCase().includes(searchTerm) ||
                    item.category.toLowerCase().includes(searchTerm)
                );
            }

            // Filter by current tab
            if (currentTab !== 'all') {
                filteredItems = filteredItems.filter(item => 
                    item.location.toLowerCase() === currentTab
                );
            }

            // Sort items
            filteredItems.sort((a, b) => {
                switch(sortBy) {
                    case 'name':
                        return a.name.localeCompare(b.name);
                    case 'date-added':
                        return b.addedDate - a.addedDate;
                    case 'location':
                        return a.location.localeCompare(b.location);
                    case 'category':
                        return a.category.localeCompare(b.category);
                    case 'expiration':
                    default:
                        const statusA = getItemStatus(a);
                        const statusB = getItemStatus(b);
                        const statusOrder = { expired: 0, warning: 1, fresh: 2 };
                        return statusOrder[statusA.status] - statusOrder[statusB.status];
                }
            });

            return filteredItems;
        }

        function getDaysInStorage(storedDate) {
            const now = new Date();
            const diffTime = Math.abs(now - storedDate);
            return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        }

        function getItemStatus(item) {
            const daysInStorage = getDaysInStorage(item.storedDate);
            const maxDays = storageGuidelines[item.location][item.category] * 30;
            
            if (maxDays === 0) {
                return { status: 'warning', daysLeft: 0, message: 'Not recommended for this location!' };
            }
            
            const warningDays = maxDays * 0.8;

            if (daysInStorage >= maxDays) {
                return { status: 'expired', daysLeft: 0, message: 'Use immediately!' };
            } else if (daysInStorage >= warningDays) {
                return { status: 'warning', daysLeft: maxDays - daysInStorage, message: `Use within ${maxDays - daysInStorage} days` };
            } else {
                return { status: 'fresh', daysLeft: maxDays - daysInStorage, message: `Good for ${maxDays - daysInStorage} more days` };
            }
        }

        function updateStats() {
            const total = foodItems.length;
            const pantryCount = foodItems.filter(item => item.location === 'Pantry').length;
            const fridgeCount = foodItems.filter(item => item.location === 'Fridge').length;
            const freezerCount = foodItems.filter(item => item.location === 'Freezer').length;
            
            let expiringSoon = 0;
            foodItems.forEach(item => {
                const status = getItemStatus(item);
                if (status.status === 'warning' || status.status === 'expired') {
                    expiringSoon++;
                }
            });

            document.getElementById('totalItems').textContent = total;
            document.getElementById('pantryItems').textContent = pantryCount;
            document.getElementById('fridgeItems').textContent = fridgeCount;
            document.getElementById('freezerItems').textContent = freezerCount;
            document.getElementById('expiringSoon').textContent = expiringSoon;
        }

        function updateDisplay() {
            const grid = document.getElementById('itemsGrid');
            
            const itemsToShow = filterAndSortItems(foodItems);
            
            if (itemsToShow.length === 0) {
                let emptyMessage = 'No items found.';
                
                if (searchTerm) {
                    emptyMessage = `No items found matching "${searchTerm}".`;
                } else if (currentTab === 'all') {
                    emptyMessage = 'Your storage is empty! Add some items to get started.';
                } else {
                    emptyMessage = `Your ${currentTab} is empty! Add some items to get started.`;
                }
                
                grid.innerHTML = `<div class="empty-state">${emptyMessage}</div>`;
                updateStats();
                return;
            }

            grid.innerHTML = itemsToShow.map(item => {
                const status = getItemStatus(item);
                const daysInStorage = getDaysInStorage(item.storedDate);
                const locationClass = `location-${item.location.toLowerCase()}`;
                
                return `
                    <div class="item-card">
                        <div class="item-header">
                            <div>
                                <div class="item-name">${item.name}</div>
                                <div class="storage-location ${locationClass}">${getLocationIcon(item.location)} ${item.location}</div>
                                <div class="item-category">${item.category}</div>
                            </div>
                        </div>
                        <div class="item-details">
                            ${item.location === 'Freezer' ? 'Frozen' : 'Added'}: ${item.storedDate.toLocaleDateString()}<br>
                            In ${item.location.toLowerCase()}: ${daysInStorage} days
                        </div>
                        <div class="days-left ${status.status}">
                            ${status.message}
                        </div>
                        <button class="delete-btn" onclick="deleteItem(${item.id})">Remove</button>
                    </div>
                `;
            }).join('');

            updateStats();
        }

        function getLocationIcon(location) {
            switch(location) {
                case 'Pantry': return '🏠';
                case 'Fridge': return '❄️';
                case 'Freezer': return '🧊';
                default: return '📦';
            }
        }

        function lookupManualBarcode() {
            const barcode = document.getElementById('manualBarcode').value.trim();
            if (!barcode) {
                showLookupStatus('Please enter a barcode', 'error');
                return;
            }
            
            if (isBatchMode) {
                addToBatchQueue(barcode, 'Manual Entry');
                document.getElementById('manualBarcode').value = '';
            } else {
                lookupProduct(barcode);
                document.getElementById('manualBarcode').value = '';
            }
        }

        function addToBatchQueue(barcode, productName = null, category = null) {
            if (batchQueue.find(item => item.barcode === barcode)) {
                showLookupStatus('Item already in batch queue', 'error');
                return;
            }

            const batchItem = {
                id: Date.now(),
                barcode: barcode,
                name: productName || `Product ${barcode}`,
                category: category || 'Other',
                status: 'pending'
            };

            batchQueue.push(batchItem);
            updateBatchDisplay();
            
            if (!productName) {
                lookupProductForBatch(barcode, batchItem.id);
            }
        }

        function updateBatchDisplay() {
            const batchCount = document.getElementById('batchCount');
            const batchItems = document.getElementById('batchItems');
            
            batchCount.textContent = batchQueue.length;
            
            if (batchQueue.length === 0) {
                batchItems.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No items in queue</div>';
                return;
            }

            batchItems.innerHTML = batchQueue.map(item => `
                <div class="batch-item">
                    <div class="batch-item-info">
                        <div class="batch-item-name">${item.name}</div>
                        <div class="batch-item-details">${item.category} • ${item.barcode} ${item.status === 'loading' ? '(looking up...)' : ''}</div>
                    </div>
                    <button class="batch-remove" onclick="removeFromBatch(${item.id})">Remove</button>
                </div>
            `).join('');
        }

        function removeFromBatch(id) {
            batchQueue = batchQueue.filter(item => item.id !== id);
            updateBatchDisplay();
        }

        function clearBatchQueue() {
            batchQueue = [];
            updateBatchDisplay();
        }

        async function addAllBatchItems() {
            if (batchQueue.length === 0) {
                showLookupStatus('No items in batch queue', 'error');
                return;
            }

            const storedDateInput = document.getElementById('storedDate').value;
            const location = document.getElementById('storageLocation').value;

            let storedDate;
            if (storedDateInput) {
                const dateParts = storedDateInput.split('-');
                storedDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
            } else {
                storedDate = new Date();
            }

            showLookupStatus('Adding items to database...', 'loading');
            let addedCount = 0;

            try {
                // Add each item to Firestore
                for (const batchItem of batchQueue) {
                    const item = {
                        id: Date.now() + Math.random(),
                        name: batchItem.name,
                        category: batchItem.category,
                        location: location,
                        storedDate: storedDate,
                        addedDate: new Date()
                    };

                    await FirestoreService.saveFoodItem(item);

                    // If not using real-time listener, add to local array
                    if (!window.firestoreUnsubscribe) {
                        foodItems.push(item);
                    }

                    addedCount++;
                }

                clearBatchQueue();
                if (!window.firestoreUnsubscribe) {
                    updateDisplay();
                }
                showLookupStatus(`Added ${addedCount} items to ${location.toLowerCase()}!`, 'success');

                if (!isBatchMode) {
                    document.getElementById('batchQueue').style.display = 'none';
                }
            } catch (error) {
                console.error('Error adding batch items:', error);
                showLookupStatus('Error adding some items. Please try again.', 'error');
            }
        }

        async function lookupProductForBatch(barcode, batchId) {
            const batchItem = batchQueue.find(item => item.id === batchId);
            if (batchItem) {
                batchItem.status = 'loading';
                updateBatchDisplay();
            }

            try {
                const productInfo = await lookupProductInfo(barcode);
                
                const batchItemIndex = batchQueue.findIndex(item => item.id === batchId);
                if (batchItemIndex !== -1 && productInfo) {
                    batchQueue[batchItemIndex].name = productInfo.name;
                    batchQueue[batchItemIndex].category = productInfo.category;
                    batchQueue[batchItemIndex].status = 'found';
                } else if (batchItemIndex !== -1) {
                    batchQueue[batchItemIndex].status = 'not_found';
                }
                
                updateBatchDisplay();
            } catch (error) {
                const batchItemIndex = batchQueue.findIndex(item => item.id === batchId);
                if (batchItemIndex !== -1) {
                    batchQueue[batchItemIndex].status = 'error';
                    updateBatchDisplay();
                }
            }
        }

        function startScanner() {
            const scanBtn = document.getElementById('scanBtn');
            const batchBtn = document.getElementById('batchBtn');
            const scannerContainer = document.getElementById('scannerContainer');
            const scanMode = document.getElementById('scanMode');
            const video = document.getElementById('video');
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showLookupStatus('Camera not supported on this device', 'error');
                return;
            }

            scanBtn.textContent = 'Starting camera...';
            scanBtn.disabled = true;
            batchBtn.disabled = true;
            scannerContainer.style.display = 'block';
            isScanning = true;

            scanMode.textContent = isBatchMode ? 'Batch Mode: Keep scanning items' : 'Single Mode: Will stop after first scan';
            
            if (isBatchMode) {
                document.getElementById('batchQueue').style.display = 'block';
            }

            navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: "environment" }
            }).then(function(stream) {
                video.srcObject = stream;
                video.setAttribute('playsinline', true);
                video.play();
                
                showLookupStatus('Camera connected, starting barcode scanner...', 'loading');
                
                Quagga.init({
                    inputStream: {
                        name: "Live", type: "LiveStream", target: video,
                        constraints: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: "environment" }
                    },
                    locator: { patchSize: "medium", halfSample: true },
                    numOfWorkers: 2, frequency: 10,
                    decoder: {
                        readers: ["ean_reader", "ean_8_reader", "code_128_reader", "code_39_reader"],
                        debug: { drawBoundingBox: true, showFrequency: false, drawScanline: true, showPattern: false }
                    },
                    locate: true
                }, function(err) {
                    if (err) {
                        console.log('Quagga init error:', err);
                        showLookupStatus('Scanner initialization failed: ' + err.message, 'error');
                        
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        stopScanner();
                        return;
                    }
                    
                    scanBtn.textContent = isBatchMode ? '🛑 Stop Batch' : '🛑 Stop Scan';
                    batchBtn.textContent = isBatchMode ? '📦 Batch Mode' : '📦 Batch Scan';
                    showLookupStatus('Ready to scan! Point camera at barcode', 'success');
                    
                    Quagga.start();
                });

            }).catch(function(err) {
                console.log('Camera access error:', err);
                showLookupStatus('Camera access denied: ' + err.message, 'error');
                stopScanner();
            });

            Quagga.onDetected(function(data) {
                const code = data.codeResult.code;
                const format = data.codeResult.format;
                
                console.log('Barcode detected:', code, 'Format:', format, 'Quality:', data.codeResult.quality);
                
                if (!isValidBarcode(code, format)) {
                    console.log('Invalid barcode detected, ignoring:', code);
                    return;
                }
                
                if (window.lastScannedCode === code && Date.now() - window.lastScanTime < 2000) {
                    return;
                }
                
                window.lastScannedCode = code;
                window.lastScanTime = Date.now();
                
                if (isBatchMode) {
                    addToBatchQueue(code);
                    showLookupStatus(`Scanned: ${code} (${format})`, 'success');
                } else {
                    stopScanner();
                    lookupProduct(code);
                }
            });
        }

        function stopScanner() {
            if (isScanning) {
                Quagga.stop();
                
                const video = document.getElementById('video');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
                
                isScanning = false;
                isBatchMode = false;
            }
            
            const scanBtn = document.getElementById('scanBtn');
            const batchBtn = document.getElementById('batchBtn');
            const scannerContainer = document.getElementById('scannerContainer');
            
            scanBtn.textContent = '📱 Scan Barcode';
            scanBtn.disabled = false;
            batchBtn.textContent = '📦 Batch Scan';
            batchBtn.disabled = false;
            scannerContainer.style.display = 'none';
        }

        async function lookupProduct(barcode) {
            showLookupStatus('Looking up product...', 'loading');
            
            const productInfo = await lookupProductInfo(barcode);
            
            if (productInfo) {
                document.getElementById('itemName').value = productInfo.name;
                document.getElementById('category').value = productInfo.category;
                showLookupStatus(`Found: ${productInfo.name}`, 'success');
            } else {
                document.getElementById('itemName').value = `Product ${barcode}`;
                showLookupStatus('Product not found in database, but barcode captured', 'error');
            }
        }

        async function lookupProductInfo(barcode) {
            try {
                let response = await fetch(`https://world.openfoodfacts.org/api/v0/product/${barcode}.json`);
                let data = await response.json();
                
                if (data.status === 1 && data.product) {
                    const product = data.product;
                    const productName = product.product_name || product.product_name_en || 'Unknown Product';
                    
                    let category = 'Other';
                    if (product.categories) {
                        category = guessCategory(product.categories.toLowerCase()) || 'Other';
                    }
                    
                    return { name: productName, category: category };
                }
                
                response = await fetch(`https://api.upcitemdb.com/prod/trial/lookup?upc=${barcode}`);
                data = await response.json();
                
                if (data.code === 'OK' && data.items && data.items.length > 0) {
                    const item = data.items[0];
                    const productName = item.title || 'Unknown Product';
                    
                    let category = 'Other';
                    if (item.category) {
                        category = guessCategory(item.category.toLowerCase()) || 'Other';
                    }
                    
                    return { name: productName, category: category };
                }
                
                return null;
                
            } catch (error) {
                console.error('Lookup error:', error);
                return null;
            }
        }

        function guessCategory(text) {
            const categoryKeywords = {
                'Meat': ['meat', 'beef', 'chicken', 'pork', 'turkey', 'fish', 'salmon', 'tuna', 'bacon', 'sausage'],
                'Vegetables': ['vegetables', 'broccoli', 'spinach', 'carrots', 'peas', 'corn', 'beans', 'potato'],
                'Dairy': ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'dairy'],
                'Grains': ['rice', 'pasta', 'bread', 'cereal', 'oats', 'quinoa', 'flour', 'wheat'],
                'Canned': ['canned', 'soup', 'sauce', 'tomato', 'beans'],
                'Snacks': ['chips', 'crackers', 'nuts', 'cookies', 'popcorn'],
                'Condiments': ['ketchup', 'mustard', 'mayo', 'dressing', 'oil', 'vinegar'],
                'Beverages': ['juice', 'soda', 'water', 'coffee', 'tea'],
                'Desserts': ['ice cream', 'frozen yogurt', 'dessert', 'cake', 'cookie', 'chocolate'],
                'Prepared': ['pizza', 'meal', 'dinner', 'lunch', 'prepared', 'frozen meal', 'burrito', 'sandwich']
            };
            
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => text.includes(keyword))) {
                    return category;
                }
            }
            
            return null;
        }

        function isValidBarcode(code, format) {
            const cleanCode = code.replace(/\D/g, '');
            
            switch(format) {
                case 'ean_13':
                case 'ean_reader':
                    return cleanCode.length === 13 && /^\d{13}$/.test(cleanCode);
                case 'ean_8':
                    return cleanCode.length === 8 && /^\d{8}$/.test(cleanCode);
                case 'code_128':
                    return cleanCode.length >= 8 && cleanCode.length <= 14 && /^\d+$/.test(cleanCode);
                case 'code_39':
                    return code.length >= 3 && code.length <= 25;
                default:
                    return cleanCode.length >= 8 && /^\d+$/.test(cleanCode);
            }
        }

        function showLookupStatus(message, type) {
            const statusDiv = document.getElementById('lookupStatus');
            statusDiv.textContent = message;
            statusDiv.className = `lookup-${type}`;
            statusDiv.style.display = 'block';
            
            if (type !== 'error') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('itemName').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addItem();
                }
            });

            const manualBarcodeInput = document.getElementById('manualBarcode');
            if (manualBarcodeInput) {
                manualBarcodeInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        lookupManualBarcode();
                    }
                });
            }

            updateDisplay();
        });

        function lookupManualBarcode() {
            const barcode = document.getElementById('manualBarcode').value.trim();
            if (!barcode) {
                showLookupStatus('Please enter a barcode', 'error');
                return;
            }
            
            if (isBatchMode) {
                addToBatchQueue(barcode, 'Manual Entry');
                document.getElementById('manualBarcode').value = '';
            } else {
                lookupProduct(barcode);
                document.getElementById('manualBarcode').value = '';
            }
        }

        function addToBatchQueue(barcode, productName = null, category = null) {
            // Check if already in queue
            if (batchQueue.find(item => item.barcode === barcode)) {
                showLookupStatus('Item already in batch queue', 'error');
                return;
            }

            const batchItem = {
                id: Date.now(),
                barcode: barcode,
                name: productName || `Product ${barcode}`,
                category: category || 'Other',
                status: 'pending'
            };

            batchQueue.push(batchItem);
            updateBatchDisplay();
            
            // If we don't have product info, try to look it up
            if (!productName) {
                lookupProductForBatch(barcode, batchItem.id);
            }
        }

        function updateBatchDisplay() {
            const batchCount = document.getElementById('batchCount');
            const batchItems = document.getElementById('batchItems');
            
            batchCount.textContent = batchQueue.length;
            
            if (batchQueue.length === 0) {
                batchItems.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No items in queue</div>';
                return;
            }

            batchItems.innerHTML = batchQueue.map(item => `
                <div class="batch-item">
                    <div class="batch-item-info">
                        <div class="batch-item-name">${item.name}</div>
                        <div class="batch-item-details">${item.category} • ${item.barcode} ${item.status === 'loading' ? '(looking up...)' : ''}</div>
                    </div>
                    <button class="batch-remove" onclick="removeFromBatch(${item.id})">Remove</button>
                </div>
            `).join('');
        }

        function removeFromBatch(id) {
            batchQueue = batchQueue.filter(item => item.id !== id);
            updateBatchDisplay();
        }

        function clearBatchQueue() {
            batchQueue = [];
            updateBatchDisplay();
        }

        function addAllBatchItems() {
            if (batchQueue.length === 0) {
                showLookupStatus('No items in batch queue', 'error');
                return;
            }

            // Get values from form
            const storedDateInput = document.getElementById('storedDate').value;
            const location = document.getElementById('storageLocation').value;
            
            let storedDate;
            
            if (storedDateInput) {
                // Fix timezone issue by creating date in local timezone
                const dateParts = storedDateInput.split('-');
                storedDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
            } else {
                storedDate = new Date();
            }

            let addedCount = 0;

            batchQueue.forEach(batchItem => {
                const item = {
                    id: Date.now() + Math.random(), // Ensure unique IDs
                    name: batchItem.name,
                    category: batchItem.category,
                    location: location,
                    storedDate: storedDate,
                    addedDate: new Date()
                };
                
                foodItems.push(item);
                addedCount++;
            });

            clearBatchQueue();
            updateDisplay();
            showLookupStatus(`Added ${addedCount} items to ${location.toLowerCase()}!`, 'success');
            
            // Hide batch queue if not in batch mode
            if (!isBatchMode) {
                document.getElementById('batchQueue').style.display = 'none';
            }
        }

        async function lookupProductForBatch(barcode, batchId) {
            // Update status to loading
            const batchItem = batchQueue.find(item => item.id === batchId);
            if (batchItem) {
                batchItem.status = 'loading';
                updateBatchDisplay();
            }

            try {
                const productInfo = await lookupProductInfo(barcode);
                
                const batchItemIndex = batchQueue.findIndex(item => item.id === batchId);
                if (batchItemIndex !== -1 && productInfo) {
                    batchQueue[batchItemIndex].name = productInfo.name;
                    batchQueue[batchItemIndex].category = productInfo.category;
                    batchQueue[batchItemIndex].status = 'found';
                } else if (batchItemIndex !== -1) {
                    batchQueue[batchItemIndex].status = 'not_found';
                }
                
                updateBatchDisplay();
            } catch (error) {
                const batchItemIndex = batchQueue.findIndex(item => item.id === batchId);
                if (batchItemIndex !== -1) {
                    batchQueue[batchItemIndex].status = 'error';
                    updateBatchDisplay();
                }
            }
        }

        function startScanner() {
            const scanBtn = document.getElementById('scanBtn');
            const batchBtn = document.getElementById('batchBtn');
            const scannerContainer = document.getElementById('scannerContainer');
            const scanMode = document.getElementById('scanMode');
            const video = document.getElementById('video');
            
            // Check if camera is supported
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showLookupStatus('Camera not supported on this device', 'error');
                return;
            }

            scanBtn.textContent = 'Starting camera...';
            scanBtn.disabled = true;
            batchBtn.disabled = true;
            scannerContainer.style.display = 'block';
            isScanning = true;

            // Show current mode
            scanMode.textContent = isBatchMode ? 'Batch Mode: Keep scanning items' : 'Single Mode: Will stop after first scan';
            
            if (isBatchMode) {
                document.getElementById('batchQueue').style.display = 'block';
            }

            // First get camera access directly
            navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: "environment"
                }
            }).then(function(stream) {
                // Set the video source to the camera stream
                video.srcObject = stream;
                video.setAttribute('playsinline', true);
                video.play();
                
                showLookupStatus('Camera connected, starting barcode scanner...', 'loading');
                
                // Now initialize Quagga with the video element
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: video,
                        constraints: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: "environment"
                        }
                    },
                    locator: {
                        patchSize: "medium",
                        halfSample: true
                    },
                    numOfWorkers: 2,
                    frequency: 10,
                    decoder: {
                        readers: [
                            "ean_reader",
                            "ean_8_reader", 
                            "code_128_reader",
                            "code_39_reader"
                        ],
                        debug: {
                            drawBoundingBox: true,
                            showFrequency: false,
                            drawScanline: true,
                            showPattern: false
                        }
                    },
                    locate: true
                }, function(err) {
                    if (err) {
                        console.log('Quagga init error:', err);
                        showLookupStatus('Scanner initialization failed: ' + err.message, 'error');
                        
                        // Stop the video stream
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        stopScanner();
                        return;
                    }
                    
                    scanBtn.textContent = isBatchMode ? '🛑 Stop Batch' : '🛑 Stop Scan';
                    batchBtn.textContent = isBatchMode ? '📦 Batch Mode' : '📦 Batch Scan';
                    showLookupStatus('Ready to scan! Point camera at barcode', 'success');
                    
                    Quagga.start();
                });

            }).catch(function(err) {
                console.log('Camera access error:', err);
                showLookupStatus('Camera access denied: ' + err.message, 'error');
                stopScanner();
            });

            Quagga.onDetected(function(data) {
                const code = data.codeResult.code;
                const format = data.codeResult.format;
                
                console.log('Barcode detected:', code, 'Format:', format, 'Quality:', data.codeResult.quality);
                
                // Validate barcode format and length
                if (!isValidBarcode(code, format)) {
                    console.log('Invalid barcode detected, ignoring:', code);
                    return;
                }
                
                // Add a brief delay to prevent multiple rapid scans of the same code
                if (window.lastScannedCode === code && Date.now() - window.lastScanTime < 2000) {
                    return;
                }
                
                window.lastScannedCode = code;
                window.lastScanTime = Date.now();
                
                if (isBatchMode) {
                    // In batch mode, add to queue and keep scanning
                    addToBatchQueue(code);
                    showLookupStatus(`Scanned: ${code} (${format})`, 'success');
                } else {
                    // In single mode, stop scanning and look up
                    stopScanner();
                    lookupProduct(code);
                }
            });
        }

        function stopScanner() {
            if (isScanning) {
                Quagga.stop();
                
                // Stop all video tracks
                const video = document.getElementById('video');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
                
                isScanning = false;
                isBatchMode = false;
            }
            
            const scanBtn = document.getElementById('scanBtn');
            const batchBtn = document.getElementById('batchBtn');
            const scannerContainer = document.getElementById('scannerContainer');
            
            scanBtn.textContent = '📱 Scan Barcode';
            scanBtn.disabled = false;
            batchBtn.textContent = '📦 Batch Scan';
            batchBtn.disabled = false;
            scannerContainer.style.display = 'none';
        }

        async function lookupProduct(barcode) {
            showLookupStatus('Looking up product...', 'loading');
            
            const productInfo = await lookupProductInfo(barcode);
            
            if (productInfo) {
                // Auto-fill the form
                document.getElementById('itemName').value = productInfo.name;
                document.getElementById('category').value = productInfo.category;
                showLookupStatus(`Found: ${productInfo.name}`, 'success');
            } else {
                // If lookup fails, just fill in the barcode
                document.getElementById('itemName').value = `Product ${barcode}`;
                showLookupStatus('Product not found in database, but barcode captured', 'error');
            }
        }

        async function lookupProductInfo(barcode) {
            try {
                // Try OpenFoodFacts API first
                let response = await fetch(`https://world.openfoodfacts.org/api/v0/product/${barcode}.json`);
                let data = await response.json();
                
                if (data.status === 1 && data.product) {
                    const product = data.product;
                    const productName = product.product_name || product.product_name_en || 'Unknown Product';
                    
                    // Try to guess category based on categories
                    let category = 'Other';
                    if (product.categories) {
                        category = guessCategory(product.categories.toLowerCase()) || 'Other';
                    }
                    
                    return { name: productName, category: category };
                }
                
                // If OpenFoodFacts fails, try UPC Database
                response = await fetch(`https://api.upcitemdb.com/prod/trial/lookup?upc=${barcode}`);
                data = await response.json();
                
                if (data.code === 'OK' && data.items && data.items.length > 0) {
                    const item = data.items[0];
                    const productName = item.title || 'Unknown Product';
                    
                    // Try to guess category from title
                    let category = 'Other';
                    if (item.category) {
                        category = guessCategory(item.category.toLowerCase()) || 'Other';
                    }
                    
                    return { name: productName, category: category };
                }
                
                return null;
                
            } catch (error) {
                console.error('Lookup error:', error);
                return null;
            }
        }

        function guessCategory(text) {
            const categoryKeywords = {
                'Meat': ['meat', 'beef', 'chicken', 'pork', 'turkey', 'fish', 'salmon', 'tuna', 'bacon', 'sausage'],
                'Vegetables': ['vegetables', 'broccoli', 'spinach', 'carrots', 'peas', 'corn', 'beans', 'potato'],
                'Dairy': ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'dairy'],
                'Grains': ['rice', 'pasta', 'bread', 'cereal', 'oats', 'quinoa', 'flour', 'wheat'],
                'Canned': ['canned', 'soup', 'sauce', 'tomato', 'beans'],
                'Snacks': ['chips', 'crackers', 'nuts', 'cookies', 'popcorn'],
                'Condiments': ['ketchup', 'mustard', 'mayo', 'dressing', 'oil', 'vinegar'],
                'Beverages': ['juice', 'soda', 'water', 'coffee', 'tea'],
                'Desserts': ['ice cream', 'frozen yogurt', 'dessert', 'cake', 'cookie', 'chocolate'],
                'Prepared': ['pizza', 'meal', 'dinner', 'lunch', 'prepared', 'frozen meal', 'burrito', 'sandwich']
            };
            
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => text.includes(keyword))) {
                    return category;
                }
            }
            
            return null;
        }

        function isValidBarcode(code, format) {
            // Remove any non-digit characters for validation
            const cleanCode = code.replace(/\D/g, '');
            
            switch(format) {
                case 'ean_13':
                case 'ean_reader':
                    return cleanCode.length === 13 && /^\d{13}$/.test(cleanCode);
                case 'ean_8':
                    return cleanCode.length === 8 && /^\d{8}$/.test(cleanCode);
                case 'code_128':
                    // UPC-A codes are often read as Code 128
                    return cleanCode.length >= 8 && cleanCode.length <= 14 && /^\d+$/.test(cleanCode);
                case 'code_39':
                    return code.length >= 3 && code.length <= 25;
                default:
                    // For unknown formats, require at least 8 digits
                    return cleanCode.length >= 8 && /^\d+$/.test(cleanCode);
            }
        }

        function showLookupStatus(message, type) {
            const statusDiv = document.getElementById('lookupStatus');
            statusDiv.textContent = message;
            statusDiv.className = `lookup-${type}`;
            statusDiv.style.display = 'block';
            
            // Hide after 5 seconds unless it's an error
            if (type !== 'error') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Handle Enter key in item name input
        document.getElementById('itemName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addItem();
            }
        });

        // Handle Enter key in manual barcode input - wait for DOM
        document.addEventListener('DOMContentLoaded', function() {
            const manualBarcodeInput = document.getElementById('manualBarcode');
            if (manualBarcodeInput) {
                manualBarcodeInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        lookupManualBarcode();
                    }
                });
            }
        });

        // Initial display update
        updateDisplay();
    </script>
</body>
</html>
