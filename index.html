<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <title>STOKD</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .add-form {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .form-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr auto;
            gap: 15px;
            align-items: end;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            background: white;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .add-btn {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            height: fit-content;
            min-height: 48px;
            touch-action: manipulation;
        }

        .add-btn:hover {
            background: #5a67d8;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-weight: 500;
        }

        .items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .item-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .item-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        }

        .item-header {
            display: flex;
            justify-content: between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .item-name {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .item-category {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .item-details {
            color: #666;
            margin-bottom: 15px;
        }

        .days-left {
            font-weight: 600;
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 15px;
        }

        .fresh { background: #d4edda; color: #155724; }
        .warning { background: #fff3cd; color: #856404; }
        .expired { background: #f8d7da; color: #721c24; }

        .delete-btn {
            width: 100%;
            padding: 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            min-height: 44px;
            touch-action: manipulation;
        }

        .delete-btn:hover {
            background: #c82333;
        }

        .scan-btn {
            width: 100%;
            padding: 15px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 48px;
            touch-action: manipulation;
        }

        .scan-btn:hover {
            background: #218838;
        }

        .scan-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        #scannerContainer {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .lookup-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .lookup-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .lookup-loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .empty-state {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2em;
            padding: 60px 20px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì¶ STOKD</h1>
            <p>Track everything in your pantry, fridge, and freezer - never waste food again!</p>
        </div>

        <div class="add-form">
            <div class="scan-section" style="margin-bottom: 20px;">
                <div class="scan-buttons" style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-bottom: 15px;">
                    <button class="scan-btn" id="scanBtn" onclick="toggleScanner()">
                        üì± Scan Barcode
                    </button>
                    <button class="scan-btn" id="batchBtn" onclick="toggleBatchMode()" style="background: #fd7e14;">
                        üì¶ Batch Scan
                    </button>
                    <button class="scan-btn" onclick="toggleManualEntry()" style="background: #6f42c1; min-width: 120px;">
                        ‚å®Ô∏è Manual Entry
                    </button>
                </div>
                
                <div id="manualEntry" style="display: none; margin-bottom: 15px;">
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="manualBarcode" placeholder="Enter barcode number..." style="flex: 1; padding: 10px; border: 2px solid #e1e5e9; border-radius: 6px; font-size: 16px;">
                        <button onclick="lookupManualBarcode()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">Lookup</button>
                    </div>
                </div>

                <div id="batchQueue" style="display: none; margin-bottom: 15px;">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 2px dashed #dee2e6;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>Batch Mode - Items in Queue: <span id="batchCount">0</span></strong>
                            <div>
                                <button onclick="addAllBatchItems()" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 5px;">Add All</button>
                                <button onclick="clearBatchQueue()" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear Queue</button>
                            </div>
                        </div>
                        <div id="batchItems" style="max-height: 200px; overflow-y: auto;"></div>
                    </div>
                </div>

                <div id="scannerContainer" style="display: none; margin-top: 15px;">
                    <div style="position: relative; display: inline-block;">
                        <video id="video" autoplay muted playsinline style="width: 100%; max-width: 400px; border-radius: 8px; display: block;"></video>
                        <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #ff0000; width: 200px; height: 100px; border-radius: 8px; pointer-events: none; box-shadow: 0 0 0 9999px rgba(0,0,0,0.3);"></div>
                    </div>
                    <div style="margin-top: 10px; text-align: center;">
                        <button onclick="stopScanner()" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Stop Scanning</button>
                        <span id="scanMode" style="margin-left: 15px; font-weight: 500;"></span>
                    </div>
                </div>
                <div id="lookupStatus" style="margin-top: 10px; padding: 10px; border-radius: 6px; display: none;"></div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label for="itemName">Item Name</label>
                    <input type="text" id="itemName" placeholder="e.g., Ground beef, Rice, Milk... or scan barcode above" required>
                </div>
                <div class="form-group">
                    <label for="storageLocation">Storage Location</label>
                    <select id="storageLocation" onchange="toggleDateField()">
                        <option value="Pantry">üè† Pantry</option>
                        <option value="Fridge">‚ùÑÔ∏è Fridge</option>
                        <option value="Freezer">üßä Freezer</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="category">Category</label>
                    <select id="category">
                        <option value="Meat">Meat</option>
                        <option value="Vegetables">Vegetables</option>
                        <option value="Dairy">Dairy</option>
                        <option value="Grains">Grains</option>
                        <option value="Canned">Canned Goods</option>
                        <option value="Snacks">Snacks</option>
                        <option value="Condiments">Condiments</option>
                        <option value="Beverages">Beverages</option>
                        <option value="Desserts">Desserts</option>
                        <option value="Prepared">Prepared Foods</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div class="form-group" id="dateGroup">
                    <label for="storedDate" id="dateLabel">Date Added</label>
                    <input type="date" id="storedDate" required>
                </div>
                <button class="add-btn" onclick="addItem()">Add Item</button>
            </div>
        </div>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-number" id="totalItems">0</div>
                <div class="stat-label">Total Items</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="pantryItems">0</div>
                <div class="stat-label">Pantry</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="fridgeItems">0</div>
                <div class="stat-label">Fridge</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="freezerItems">0</div>
                <div class="stat-label">Freezer</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="expiringSoon">0</div>
                <div class="stat-label">Use Soon</div>
            </div>
        </div>

        <div class="storage-tabs">
            <button class="tab-btn active" onclick="switchTab('all')" id="allTab">All Items</button>
            <button class="tab-btn" onclick="switchTab('pantry')" id="pantryTab">üè† Pantry</button>
            <button class="tab-btn" onclick="switchTab('fridge')" id="fridgeTab">‚ùÑÔ∏è Fridge</button>
            <button class="tab-btn" onclick="switchTab('freezer')" id="freezerTab">üßä Freezer</button>
        </div>

        <div class="items-grid" id="itemsGrid">
            <div class="empty-state">
                Your storage is empty! Add some items to get started.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
    <script>
        let foodItems = [];
        let isScanning = false;
        let isBatchMode = false;
        let batchQueue = [];
        let currentTab = 'all';

        // Set today's date as default
        document.getElementById('storedDate').valueAsDate = new Date();

        // Storage guidelines (months) - varies by location
        const storageGuidelines = {
            'Pantry': {
                'Meat': 0, // No meat in pantry
                'Vegetables': 12, // Canned/dried
                'Dairy': 0, // No dairy in pantry
                'Grains': 24,
                'Canned': 36,
                'Snacks': 12,
                'Condiments': 24,
                'Beverages': 12,
                'Desserts': 12,
                'Prepared': 6, // Shelf-stable
                'Other': 12
            },
            'Fridge': {
                'Meat': 0.25, // 1 week
                'Vegetables': 2,
                'Dairy': 1,
                'Grains': 1, // Cooked grains
                'Canned': 0.5, // Once opened
                'Snacks': 3,
                'Condiments': 6, // Once opened
                'Beverages': 1,
                'Desserts': 1,
                'Prepared': 0.25, // 1 week
                'Other': 1
            },
            'Freezer': {
                'Meat': 6,
                'Vegetables': 12,
                'Dairy': 3,
                'Grains': 6,
                'Canned': 0, // Don't freeze cans
                'Snacks': 6,
                'Condiments': 12,
                'Beverages': 6,
                'Desserts': 4,
                'Prepared': 3,
                'Other': 6
            }
        };

        function toggleDateField() {
            const location = document.getElementById('storageLocation').value;
            const dateLabel = document.getElementById('dateLabel');
            
            if (location === 'Freezer') {
                dateLabel.textContent = 'Date Frozen';
            } else {
                dateLabel.textContent = 'Date Added';
            }
        }

        function addItem() {
            const name = document.getElementById('itemName').value.trim();
            const category = document.getElementById('category').value;
            const location = document.getElementById('storageLocation').value;
            const storedDate = document.getElementById('storedDate').value;

            if (!name || !storedDate) {
                alert('Please fill in all fields!');
                return;
            }

            // Fix timezone issue by creating date in local timezone
            const dateParts = storedDate.split('-');
            const localDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);

            const item = {
                id: Date.now(),
                name: name,
                category: category,
                location: location,
                storedDate: localDate,
                addedDate: new Date()
            };

            foodItems.push(item);
            
            // Clear form
            document.getElementById('itemName').value = '';
            document.getElementById('storedDate').valueAsDate = new Date();

            updateDisplay();
        }

        function deleteItem(id) {
            foodItems = foodItems.filter(item => item.id !== id);
            updateDisplay();
        }

        function switchTab(tab) {
            currentTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tab + 'Tab').classList.add('active');
            
            updateDisplay();
        }

        function getDaysInStorage(storedDate) {
            const now = new Date();
            const diffTime = Math.abs(now - storedDate);
            return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        }

        function getItemStatus(item) {
            const daysInStorage = getDaysInStorage(item.storedDate);
            const maxDays = storageGuidelines[item.location][item.category] * 30; // Convert months to days
            
            // If storage time is 0 (not recommended for this location), mark as warning
            if (maxDays === 0) {
                return { status: 'warning', daysLeft: 0, message: 'Not recommended for this location!' };
            }
            
            const warningDays = maxDays * 0.8; // 80% of max storage time

            if (daysInStorage >= maxDays) {
                return { status: 'expired', daysLeft: 0, message: 'Use immediately!' };
            } else if (daysInStorage >= warningDays) {
                return { status: 'warning', daysLeft: maxDays - daysInStorage, message: `Use within ${maxDays - daysInStorage} days` };
            } else {
                return { status: 'fresh', daysLeft: maxDays - daysInStorage, message: `Good for ${maxDays - daysInStorage} more days` };
            }
        }

        function updateStats() {
            const total = foodItems.length;
            const pantryCount = foodItems.filter(item => item.location === 'Pantry').length;
            const fridgeCount = foodItems.filter(item => item.location === 'Fridge').length;
            const freezerCount = foodItems.filter(item => item.location === 'Freezer').length;
            
            let expiringSoon = 0;

            foodItems.forEach(item => {
                const status = getItemStatus(item);
                if (status.status === 'warning' || status.status === 'expired') {
                    expiringSoon++;
                }
            });

            document.getElementById('totalItems').textContent = total;
            document.getElementById('pantryItems').textContent = pantryCount;
            document.getElementById('fridgeItems').textContent = fridgeCount;
            document.getElementById('freezerItems').textContent = freezerCount;
            document.getElementById('expiringSoon').textContent = expiringSoon;
        }

        function updateDisplay() {
            const grid = document.getElementById('itemsGrid');
            
            // Filter items based on current tab
            let itemsToShow = foodItems;
            if (currentTab !== 'all') {
                itemsToShow = foodItems.filter(item => item.location.toLowerCase() === currentTab);
            }
            
            if (itemsToShow.length === 0) {
                const emptyMessage = currentTab === 'all' ? 
                    'Your storage is empty! Add some items to get started.' :
                    `Your ${currentTab} is empty! Add some items to get started.`;
                grid.innerHTML = `<div class="empty-state">${emptyMessage}</div>`;
                updateStats();
                return;
            }

            // Sort by status (expired first, then warning, then fresh)
            const sortedItems = [...itemsToShow].sort((a, b) => {
                const statusA = getItemStatus(a);
                const statusB = getItemStatus(b);
                const statusOrder = { expired: 0, warning: 1, fresh: 2 };
                return statusOrder[statusA.status] - statusOrder[statusB.status];
            });

            grid.innerHTML = sortedItems.map(item => {
                const status = getItemStatus(item);
                const daysInStorage = getDaysInStorage(item.storedDate);
                const locationClass = `location-${item.location.toLowerCase()}`;
                
                return `
                    <div class="item-card">
                        <div class="item-header">
                            <div>
                                <div class="item-name">${item.name}</div>
                                <div class="storage-location ${locationClass}">${getLocationIcon(item.location)} ${item.location}</div>
                                <div class="item-category">${item.category}</div>
                            </div>
                        </div>
                        <div class="item-details">
                            ${item.location === 'Freezer' ? 'Frozen' : 'Added'}: ${item.storedDate.toLocaleDateString()}<br>
                            In ${item.location.toLowerCase()}: ${daysInStorage} days
                        </div>
                        <div class="days-left ${status.status}">
                            ${status.message}
                        </div>
                        <button class="delete-btn" onclick="deleteItem(${item.id})">Remove</button>
                    </div>
                `;
            }).join('');

            updateStats();
        }

        function getLocationIcon(location) {
            switch(location) {
                case 'Pantry': return 'üè†';
                case 'Fridge': return '‚ùÑÔ∏è';
                case 'Freezer': return 'üßä';
                default: return 'üì¶';
            }
        }

        // Handle Enter key in item name input
        document.getElementById('itemName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addItem();
            }
        });

        // Handle Enter key in manual barcode input
        document.getElementById('manualBarcode').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                lookupManualBarcode();
            }
        });

        // Initial display update
        updateDisplay();

        // Barcode scanning functions
        function toggleScanner() {
            if (isScanning) {
                stopScanner();
            } else {
                isBatchMode = false;
                startScanner();
            }
        }

        function toggleBatchMode() {
            if (isScanning && isBatchMode) {
                stopScanner();
            } else {
                isBatchMode = true;
                document.getElementById('batchQueue').style.display = 'block';
                startScanner();
            }
        }

        function toggleManualEntry() {
            const manualEntry = document.getElementById('manualEntry');
            const isVisible = manualEntry.style.display !== 'none';
            manualEntry.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                document.getElementById('manualBarcode').focus();
            }
        }

        function lookupManualBarcode() {
            const barcode = document.getElementById('manualBarcode').value.trim();
            if (!barcode) {
                showLookupStatus('Please enter a barcode', 'error');
                return;
            }
            
            if (isBatchMode) {
                addToBatchQueue(barcode, 'Manual Entry');
                document.getElementById('manualBarcode').value = '';
            } else {
                lookupProduct(barcode);
                document.getElementById('manualBarcode').value = '';
            }
        }

        function addToBatchQueue(barcode, productName = null, category = null) {
            // Check if already in queue
            if (batchQueue.find(item => item.barcode === barcode)) {
                showLookupStatus('Item already in batch queue', 'error');
                return;
            }

            const batchItem = {
                id: Date.now(),
                barcode: barcode,
                name: productName || `Product ${barcode}`,
                category: category || 'Other',
                status: 'pending'
            };

            batchQueue.push(batchItem);
            updateBatchDisplay();
            
            // If we don't have product info, try to look it up
            if (!productName) {
                lookupProductForBatch(barcode, batchItem.id);
            }
        }

        function updateBatchDisplay() {
            const batchCount = document.getElementById('batchCount');
            const batchItems = document.getElementById('batchItems');
            
            batchCount.textContent = batchQueue.length;
            
            if (batchQueue.length === 0) {
                batchItems.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No items in queue</div>';
                return;
            }

            batchItems.innerHTML = batchQueue.map(item => `
                <div class="batch-item">
                    <div class="batch-item-info">
                        <div class="batch-item-name">${item.name}</div>
                        <div class="batch-item-details">${item.category} ‚Ä¢ ${item.barcode} ${item.status === 'loading' ? '(looking up...)' : ''}</div>
                    </div>
                    <button class="batch-remove" onclick="removeFromBatch(${item.id})">Remove</button>
                </div>
            `).join('');
        }

        function removeFromBatch(id) {
            batchQueue = batchQueue.filter(item => item.id !== id);
            updateBatchDisplay();
        }

        function clearBatchQueue() {
            batchQueue = [];
            updateBatchDisplay();
        }

        function addAllBatchItems() {
            if (batchQueue.length === 0) {
                showLookupStatus('No items in batch queue', 'error');
                return;
            }

            // Get values from form
            const storedDateInput = document.getElementById('storedDate').value;
            const location = document.getElementById('storageLocation').value;
            
            let storedDate;
            
            if (storedDateInput) {
                // Fix timezone issue by creating date in local timezone
                const dateParts = storedDateInput.split('-');
                storedDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
            } else {
                storedDate = new Date();
            }

            let addedCount = 0;

            batchQueue.forEach(batchItem => {
                const item = {
                    id: Date.now() + Math.random(), // Ensure unique IDs
                    name: batchItem.name,
                    category: batchItem.category,
                    location: location,
                    storedDate: storedDate,
                    addedDate: new Date()
                };
                
                foodItems.push(item);
                addedCount++;
            });

            clearBatchQueue();
            updateDisplay();
            showLookupStatus(`Added ${addedCount} items to ${location.toLowerCase()}!`, 'success');
            
            // Hide batch queue if not in batch mode
            if (!isBatchMode) {
                document.getElementById('batchQueue').style.display = 'none';
            }
        }er!`, 'success');
            
            // Hide batch queue if not in batch mode
            if (!isBatchMode) {
                document.getElementById('batchQueue').style.display = 'none';
            }
        }

        async function lookupProductForBatch(barcode, batchId) {
            // Update status to loading
            const batchItem = batchQueue.find(item => item.id === batchId);
            if (batchItem) {
                batchItem.status = 'loading';
                updateBatchDisplay();
            }

            try {
                const productInfo = await lookupProductInfo(barcode);
                
                const batchItemIndex = batchQueue.findIndex(item => item.id === batchId);
                if (batchItemIndex !== -1 && productInfo) {
                    batchQueue[batchItemIndex].name = productInfo.name;
                    batchQueue[batchItemIndex].category = productInfo.category;
                    batchQueue[batchItemIndex].status = 'found';
                } else if (batchItemIndex !== -1) {
                    batchQueue[batchItemIndex].status = 'not_found';
                }
                
                updateBatchDisplay();
            } catch (error) {
                const batchItemIndex = batchQueue.findIndex(item => item.id === batchId);
                if (batchItemIndex !== -1) {
                    batchQueue[batchItemIndex].status = 'error';
                    updateBatchDisplay();
                }
            }
        }

        function startScanner() {
            const scanBtn = document.getElementById('scanBtn');
            const batchBtn = document.getElementById('batchBtn');
            const scannerContainer = document.getElementById('scannerContainer');
            const scanMode = document.getElementById('scanMode');
            const video = document.getElementById('video');
            
            // Check if camera is supported
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showLookupStatus('Camera not supported on this device', 'error');
                return;
            }

            scanBtn.textContent = 'Starting camera...';
            scanBtn.disabled = true;
            batchBtn.disabled = true;
            scannerContainer.style.display = 'block';
            isScanning = true;

            // Show current mode
            scanMode.textContent = isBatchMode ? 'Batch Mode: Keep scanning items' : 'Single Mode: Will stop after first scan';
            
            if (isBatchMode) {
                document.getElementById('batchQueue').style.display = 'block';
            }

            // First get camera access directly
            navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: "environment"
                }
            }).then(function(stream) {
                // Set the video source to the camera stream
                video.srcObject = stream;
                video.setAttribute('playsinline', true);
                video.play();
                
                showLookupStatus('Camera connected, starting barcode scanner...', 'loading');
                
                // Now initialize Quagga with the video element
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: video,
                        constraints: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: "environment"
                        }
                    },
                    locator: {
                        patchSize: "medium",
                        halfSample: true
                    },
                    numOfWorkers: 2,
                    frequency: 10,
                    decoder: {
                        readers: [
                            "ean_reader",
                            "ean_8_reader", 
                            "code_128_reader",
                            "code_39_reader"
                        ],
                        debug: {
                            drawBoundingBox: true,
                            showFrequency: false,
                            drawScanline: true,
                            showPattern: false
                        }
                    },
                    locate: true
                }, function(err) {
                    if (err) {
                        console.log('Quagga init error:', err);
                        showLookupStatus('Scanner initialization failed: ' + err.message, 'error');
                        
                        // Stop the video stream
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        stopScanner();
                        return;
                    }
                    
                    scanBtn.textContent = isBatchMode ? 'üõë Stop Batch' : 'üõë Stop Scan';
                    batchBtn.textContent = isBatchMode ? 'üì¶ Batch Mode' : 'üì¶ Batch Scan';
                    showLookupStatus('Ready to scan! Point camera at barcode', 'success');
                    
                    Quagga.start();
                });

            }).catch(function(err) {
                console.log('Camera access error:', err);
                showLookupStatus('Camera access denied: ' + err.message, 'error');
                stopScanner();
            });

            Quagga.onDetected(function(data) {
                const code = data.codeResult.code;
                const format = data.codeResult.format;
                
                console.log('Barcode detected:', code, 'Format:', format, 'Quality:', data.codeResult.quality);
                
                // Validate barcode format and length
                if (!isValidBarcode(code, format)) {
                    console.log('Invalid barcode detected, ignoring:', code);
                    return;
                }
                
                // Add a brief delay to prevent multiple rapid scans of the same code
                if (window.lastScannedCode === code && Date.now() - window.lastScanTime < 2000) {
                    return;
                }
                
                window.lastScannedCode = code;
                window.lastScanTime = Date.now();
                
                if (isBatchMode) {
                    // In batch mode, add to queue and keep scanning
                    addToBatchQueue(code);
                    showLookupStatus(`Scanned: ${code} (${format})`, 'success');
                } else {
                    // In single mode, stop scanning and look up
                    stopScanner();
                    lookupProduct(code);
                }
            });
        }

        function stopScanner() {
            if (isScanning) {
                Quagga.stop();
                
                // Stop all video tracks
                const video = document.getElementById('video');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
                
                isScanning = false;
                isBatchMode = false;
            }
            
            const scanBtn = document.getElementById('scanBtn');
            const batchBtn = document.getElementById('batchBtn');
            const scannerContainer = document.getElementById('scannerContainer');
            
            scanBtn.textContent = 'üì± Scan Barcode';
            scanBtn.disabled = false;
            batchBtn.textContent = 'üì¶ Batch Scan';
            batchBtn.disabled = false;
            scannerContainer.style.display = 'none';
        }

        async function lookupProduct(barcode) {
            showLookupStatus('Looking up product...', 'loading');
            
            const productInfo = await lookupProductInfo(barcode);
            
            if (productInfo) {
                // Auto-fill the form
                document.getElementById('itemName').value = productInfo.name;
                document.getElementById('category').value = productInfo.category;
                showLookupStatus(`Found: ${productInfo.name}`, 'success');
            } else {
                // If lookup fails, just fill in the barcode
                document.getElementById('itemName').value = `Product ${barcode}`;
                showLookupStatus('Product not found in database, but barcode captured', 'error');
            }
        }

        async function lookupProductInfo(barcode) {
            try {
                // Try OpenFoodFacts API first
                let response = await fetch(`https://world.openfoodfacts.org/api/v0/product/${barcode}.json`);
                let data = await response.json();
                
                if (data.status === 1 && data.product) {
                    const product = data.product;
                    const productName = product.product_name || product.product_name_en || 'Unknown Product';
                    
                    // Try to guess category based on categories
                    let category = 'Other';
                    if (product.categories) {
                        category = guessCategory(product.categories.toLowerCase()) || 'Other';
                    }
                    
                    return { name: productName, category: category };
                }
                
                // If OpenFoodFacts fails, try UPC Database
                response = await fetch(`https://api.upcitemdb.com/prod/trial/lookup?upc=${barcode}`);
                data = await response.json();
                
                if (data.code === 'OK' && data.items && data.items.length > 0) {
                    const item = data.items[0];
                    const productName = item.title || 'Unknown Product';
                    
                    // Try to guess category from title
                    let category = 'Other';
                    if (item.category) {
                        category = guessCategory(item.category.toLowerCase()) || 'Other';
                    }
                    
                    return { name: productName, category: category };
                }
                
                return null;
                
            } catch (error) {
                console.error('Lookup error:', error);
                return null;
            }
        }

        function guessCategory(text) {
            const categoryKeywords = {
                'Meat': ['meat', 'beef', 'chicken', 'pork', 'turkey', 'fish', 'salmon', 'tuna', 'bacon', 'sausage'],
                'Vegetables': ['vegetables', 'broccoli', 'spinach', 'carrots', 'peas', 'corn', 'beans', 'potato'],
                'Dairy': ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'dairy'],
                'Grains': ['rice', 'pasta', 'bread', 'cereal', 'oats', 'quinoa', 'flour', 'wheat'],
                'Canned': ['canned', 'soup', 'sauce', 'tomato', 'beans'],
                'Snacks': ['chips', 'crackers', 'nuts', 'cookies', 'popcorn'],
                'Condiments': ['ketchup', 'mustard', 'mayo', 'dressing', 'oil', 'vinegar'],
                'Beverages': ['juice', 'soda', 'water', 'coffee', 'tea'],
                'Desserts': ['ice cream', 'frozen yogurt', 'dessert', 'cake', 'cookie', 'chocolate'],
                'Prepared': ['pizza', 'meal', 'dinner', 'lunch', 'prepared', 'frozen meal', 'burrito', 'sandwich']
            };
            
            for (const [category, keywords] of Object.entries(categoryKeywords)) {
                if (keywords.some(keyword => text.includes(keyword))) {
                    return category;
                }
            }
            
            return null;
        }

        function isValidBarcode(code, format) {
            // Remove any non-digit characters for validation
            const cleanCode = code.replace(/\D/g, '');
            
            switch(format) {
                case 'ean_13':
                case 'ean_reader':
                    return cleanCode.length === 13 && /^\d{13}$/.test(cleanCode);
                case 'ean_8':
                    return cleanCode.length === 8 && /^\d{8}$/.test(cleanCode);
                case 'code_128':
                    // UPC-A codes are often read as Code 128
                    return cleanCode.length >= 8 && cleanCode.length <= 14 && /^\d+$/.test(cleanCode);
                case 'code_39':
                    return code.length >= 3 && code.length <= 25;
                default:
                    // For unknown formats, require at least 8 digits
                    return cleanCode.length >= 8 && /^\d+$/.test(cleanCode);
            }
        }

        function showLookupStatus(message, type) {
            const statusDiv = document.getElementById('lookupStatus');
            statusDiv.textContent = message;
            statusDiv.className = `lookup-${type}`;
            statusDiv.style.display = 'block';
            
            // Hide after 5 seconds unless it's an error
            if (type !== 'error') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
    </script>
</body>
</html>
